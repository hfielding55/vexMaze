{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n\ndef when_started1():\n\n    #FIND MOST EFFICIENT PATH + ESCAPE\n\n    global coords #made global so i can monitor\n    global pathingArray\n    global returning\n    coords = [0,0]\n    pathingArray = [[0,0]]\n    global endCoords\n    endCoords = []\n    returning = False #stores whether it has just deleted from the pathingArray\n    #monitor_variable(\"coords\", \"pathingArray\", \"returning\")\n    #monitor_sensor(\"down_eye.detect\", \"down_eye.brightness\")\n\n    drivetrain.set_drive_velocity(1000, PERCENT)\n    drivetrain.set_turn_velocity(1000, PERCENT)\n\n    #-----------\n\n    \n\n\n\n\n\n\n\n\n\n\n\n    while True:\n        angle = location.position_angle(DEGREES)\n        if down_eye.detect(RED): #check for the end of the maze\n            endCoords = coords\n            break\n        drivetrain.turn_for(RIGHT, 90, DEGREES)      # -} follows right wall\n        while True:                                   # |\n            if front_eye.near_object() == True:       # |\n                drivetrain.turn_for(LEFT, 90, DEGREES)# |\n            else:                                     # |\n                break                                # -}\n\n        if changeCoords(coords) not in pathingArray and returning == True: \n            pathingArray.append(coords) #if a coord has just been deleted but the next square is new then it puts the deleted coord back\n            returning = False #it prevents junctions from being deleted when they run back over it\n\n        drivetrain.drive_for(FORWARD, 250, MM)\n\n        coords = changeCoords(coords) #checks if its going back on itself\n        if coords in pathingArray: #if it is then it removes down to that coord on the map\n            pathingArray = pathingArray[0:pathingArray.index(coords)] #removes down to the coord, not just the latest point in case it loops on itself\n            returning = True\n        else:\n            pathingArray.append(coords)\n        \n\n    #PATH BACK TO HOME\n    \n    drivetrain.turn_for(LEFT, 360, DEGREES) #victory spin\n\n    pen.move(DOWN) #pen down to draw the path back\n    global returnArray\n    returnArray = pathingArray.copy() #copied to save the path\n    returnArray.pop(len(returnArray) - 1) #removes finish of maze\n    #monitor_variable(\"returnArray\")\n    while True: #loops through return array to path home\n        wait(5,MSEC)\n        if len(returnArray) == 0:\n            break\n        nextCoord = returnArray[len(returnArray) - 1]\n        direction = 0\n        if coords[0] != nextCoord[0]: #finds if next coord is on the x or y axis\n            direction = 0\n        else:\n            direction = 1\n        if coords[direction] > nextCoord[direction]: #changes direction to face the next coord\n            drivetrain.turn_to_heading(270 - (direction * 90), DEGREES)\n        else:\n            drivetrain.turn_to_heading(90 - (direction * 90), DEGREES)\n        \n        drivetrain.drive_for(FORWARD, 250, MM)\n        coords = nextCoord\n        returnArray.pop(len(returnArray) - 1)\n    pen.move(UP)\n\n    #MAP THE MAZE\n\n    # example block [0,0,0,0] = x,y,UP,RIGHT \n    global mappingArray\n    global visitedArray\n    global routes\n    global equaliser\n    mappingArray = []\n    visitedArray = []\n    routes = 0\n    equaliser = 0\n    monitor_variable(\"routes\", \"visitedArray\", \"equaliser\")\n\n    if endCoords[1] % 2 == 0: #since some x coords are negative, this offsets it to be minimum 0\n        equaliser = (endCoords[1] / 2) + 1\n    else:\n        equaliser = (endCoords[1] + 1) / 2\n    equaliser = int(equaliser)\n\n    drivetrain.turn_to_heading(270, DEGREES)\n    for x in range(3): #checks for how many paths from home there is\n        if front_eye.near_object() == False:\n            routes += 1\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    while True: #inside while loop to delete tempArray when finished\n        tempArray = []\n        for x in range(endCoords[1] + 1):\n            tempArray.append([0,0,0,0]) ##sets up mappingArray to be filled\n        for x in range(endCoords[1] + 1):\n            mappingArray.append(tempArray.copy())\n        break\n    \n\n    \n    while routes > 0:\n        if coords not in visitedArray: #checks if its already registered the info\n            visitedArray.append(coords)\n            saveAngle = location.position_angle(DEGREES) #saves angle to reset after checking walls\n            upWall = 0\n            rightWall = 0\n            drivetrain.turn_to_heading(0, DEGREES)\n            if front_eye.near_object(): \n                upWall = 1 #checks above and to the right on each block. we can assume outer walls are blocked\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n            if front_eye.near_object():\n                rightWall = 1\n            \n            mappingArray[coords[1]][(coords[0] + equaliser)] = [coords[0],coords[1],upWall,rightWall]\n\n            drivetrain.turn_to_heading(saveAngle, DEGREES) #resets angle to consider driving loop\n        \n        drivetrain.turn_for(RIGHT, 90, DEGREES)      # -} follows right wall\n        while True:                                   # |\n            if front_eye.near_object() == True or (coords[1] == endCoords[1] and (location.position_angle(DEGREES) == 0 or location.position_angle(DEGREES) == 360)) or (coords[1] == 0 and (location.position_angle(DEGREES) == 180)):\n                drivetrain.turn_for(LEFT, 90, DEGREES)# | ^^^ checks edge cases where you can drive off\n            else:                                     # |\n                break                                # -}\n        drivetrain.drive_for(FORWARD, 250, MM)\n        coords = changeCoords(coords)\n        if coords == [0,0]:\n            routes = routes - 1 #goes down whenever passing home. will have seen full map when routes is 0\n\n    #PLOT MAP IN ARRAY\n\n    keyNum = endCoords[1] + 1\n    plottedMap = []\n    corner = \"+\"\n    vertWall = \"|\"\n    horWall = \"---\"\n    emptyHor = \"   \" #building blocks\n    emptyVert = \" \"\n    end = \"EEE\"\n    start = \"SSS\"\n    path = \" X \"\n\n    for x in range(keyNum + 1):\n        driveLine = \"\"\n        wallLine = \"\"\n        if x == 0: #base line\n            for y in range(keyNum):\n                wallLine += corner + horWall\n            wallLine += corner\n            plottedMap.append(wallLine)\n        else:\n            driveLine += vertWall #creates line on and above\n            wallLine += corner\n            for y in range(keyNum):\n                current = mappingArray[x - 1][y] #current coord of [x,y,wall,wall]\n                currentCoords = [current[0],current[1]]\n                if currentCoords == [0,0]:\n                    driveLine += start\n                elif currentCoords == endCoords:\n                    driveLine += end\n                elif currentCoords in pathingArray:\n                    driveLine += mapDirection(currentCoords, pathingArray)\n                else:\n                    driveLine += emptyHor\n\n                wallLine += horWall if current[2] == 1 else emptyHor \n                driveLine += vertWall if current[3] == 1 else emptyVert\n                wallLine += corner\n            plottedMap.append(driveLine)\n            plottedMap.append(wallLine)\n\n    for x in range(len(plottedMap)):\n        brain.print(plottedMap[(len(plottedMap) - 1) - x] + \"\\n\")\n\n\n# desired output\n#16 +---+---+---+---+---+---+---+---+\n#15 |       |   |EEE|       |       |\n#14 +   +   +   +   +---+   +---+   +\n#13 |   |       | ^   <   <   <   < |\n#12 +   +---+---+---+---+---+---+   +\n#11 |         >   >   >   ↓     | ^ |\n#10 +---+---+   +---+---+   +---+   +\n# 9 |       | ^ |   | ↓   < | >   ^ |\n# 8 +   +   +   +   +   +---+   +---+\n# 7 |   |   | ^   < | ↓ | >   ^     |\n# 6 +---+   +---+   +   +   +---+---+\n# 5 |       |     ^ | >   ^ |       |\n# 4 +   +---+   +   +---+---+---+   +\n# 3 |           | ^   < |           |\n# 2 +---+---+---+---+   +   +   +---+\n# 1 |                SSS    |       |\n# 0 +---+---+---+---+---+---+---+---+\n\n\ndef changeCoords(cor): #function to set the next coordinate based off angle of the robot\n    if location.position_angle(DEGREES) == 0 or location.position_angle(DEGREES) == 360: \n        cor = [cor[0], cor[1] + 1] # ^^^ checks for both since sometimes up is 0 or 360\n    elif location.position_angle(DEGREES) == 90:\n        cor = [cor[0] + 1, cor[1]]\n    elif location.position_angle(DEGREES) == 180:\n        cor = [cor[0], cor[1] - 1]\n    else:\n        cor = [cor[0] - 1, cor[1]]\n    return cor\n\ndef mapDirection(cor, pathing):\n    value = \"\"\n    index = pathing.index(cor)\n    nextCor = pathing[index + 1]\n    if cor[0] != nextCor[0]: #finds if next coord is on the x or y axis\n        direction = 0\n    else:\n        direction = 1\n    \n    if cor[direction] > nextCor[direction]: #figures out direction the path takes and responds with the right arrow\n        value = \" ↓ \" if direction == 1 else \" ← \"\n    else:\n        value = \" ↑ \" if direction == 1 else \" → \"\n    return value\n\n\nvr_thread(when_started1)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}